# data-structure-cookies :cookie:
> re-inventing the wheel w/ data structures

> collection of common data structure problems

## :wrench: Useful Mechanisms To Remember
> list of useful mechanisms (functions) to remember

### 1. Arrays
1. `define dynamic array class` (1-1. dynamic array)
2. `methods for rotating array in-place` (1-2. rotate array :star:)
    - shift array by one by one
    - cyclic replacement in array
    - use reverse to rotate array by k
3. `binary search for condition to find rotation point` (1-3. rotation pivot :star:)
    - rotation point == smallest value's index
4. `left shift: end -> begin | right shift: begin -> end` (1-2. rotate array & 1-3. rotation pivot)
5. `use two pointers for ranging` (1-3. rotation pivot & 1-4. reverse array)
6. `one-pass hash table for fast lookup time` (1-6. find pair sum)
7. `(left <= right)` and `return false at end` for binary search (1-7. search element)
8. (1-8. merge two arrays :star:)

#### + Strings

#### + Matrixes

### 2. Linked List
1. `define singly-linked list class` & `define doubly-linked list class`  (2-1. singly linked list & 2-2. doubly linked list)
2. `check 2 cases for deletion: delete head & delete others` (2-1. singly linked list & 2-2. doubly linked list :star:)
    - delete head: O(1)
    - delete other nodes: O(n)
3. `two pointer technique` (2-3. find nth node)
    - `n-wide stick approach`
    - `turtle and hare approach`
4. `reverse linked list in-place` (2-4. reverse list :star:)
    - reverse data values
    - reverse ptr directions
5. `how to use two runner for cycle detection` (2-7. cycle detection :star:)

### 3. Stack
1. 
2. `reverse order` (2-4. reverse list)

### 4. Queue

### 5. Tree

#### + Binary Tree
1. `check only current node for order traversal` (5(1)-2. pre-order / in-order / post-order traversal)
2. `use recursion to calculate height of binary tree` (5(1)-3. tree height)
3. `check root or !root as base case` (5(1)-2. order traversals & 5(1)-3. tree height)

#### + Binary Search Tree (BST)
2. `use binary search mechanism to check if node exists in BST` (5(2)-2. least common ancestor)
3. `use divide-and-conquer method to find Least Common Ancestor` (5(2)-2. least common ancestor)

#### + Heap

### 6. Graph

### 7. Hashing


